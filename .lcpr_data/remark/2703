{"data":[{"name":"2023-03-02 12:54:04","id":1677732844820,"body":"超时\nclass Solution\n{\npublic:\n    vector<long long> handleQuery(vector<int> &nums1, vector<int> &nums2, vector<vector<int>> &queries)\n    {\n        vector<int> flag_1(nums1.size() + 10);\n        long long cur_sum = 0;\n        for (int j : nums2)\n        {\n            cur_sum += j;\n        }\n\n        // 前缀合\n\n        vector<long long> result;\n        for (int i = 0; i < queries.size(); i++)\n        {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            int c = queries[i][2];\n\n            if (a == 1)\n            {\n                flag_1[b]++;\n                flag_1[c + 1]--;\n            }\n            else if (a == 2)\n            {\n                long long add = 0;\n                int temp = 0;\n                for (int i = 0; i < nums1.size(); i++)\n                {\n                    temp += flag_1[i];\n                    int cur = temp + nums1[i];\n                    if (cur % 2 == 1)\n                    {\n                        add++;\n                    }\n                }\n                cur_sum += (add * b);\n            }\n            else if (a == 3)\n            {\n                result.push_back(cur_sum);\n            }\n        }\n        return result;\n    }\n};"},{"name":"2023-03-02 14:01:35","id":1677736895276,"body":"没有缓冲递推会超时\nclass segmentTree\n{\nprivate:\n    class segmentTreeNode\n    {\n    public:\n        segmentTreeNode(int l, int r)\n        {\n            left = l;\n            right = r;\n            val = 0;\n            temp_add = 0;\n            sum = 0;\n            left_son = nullptr;\n            right_son = nullptr;\n            push_down_flag = true;\n        }\n        int id;\n        int left;\n        int right;\n        int sum = 0;\n        bool push_down_flag;\n        long long val;\n        long long temp_add;\n        segmentTreeNode *left_son;\n        segmentTreeNode *right_son;\n    };\n\n    int all_left, all_right;\n\n    void pushup(segmentTreeNode *cur_node)\n    {\n        cur_node->sum = (cur_node->left_son->sum + cur_node->right_son->sum);\n    }\n\n    void modify(segmentTreeNode *cur_node, int cur_l, int cur_r, int need_L, int need_R, long long add)\n    {\n        cur_node->push_down_flag = true;\n        //  cur_l   need_L  need_R  cur_r\n        //  范围外\n        if (cur_l > need_R || cur_r < need_L)\n        {\n            return;\n        }\n        // 到底了\n        if (cur_l == cur_r)\n        {\n            cur_node->val = ((cur_node->val + add) % 2);\n            cur_node->sum = cur_node->val;\n            return;\n        }\n\n        // 继续下推\n        int mid = (cur_l + cur_r) >> 1;\n        if (cur_node->left_son == nullptr)\n        {\n            cur_node->left_son = new segmentTreeNode(cur_l, mid);\n        }\n        if (cur_node->right_son == nullptr)\n        {\n            cur_node->right_son = new segmentTreeNode((mid + 1), cur_r);\n        }\n        modify(cur_node->left_son, cur_l, mid, need_L, need_R, add);\n        modify(cur_node->right_son, mid + 1, cur_r, need_L, need_R, add);\n        pushup(cur_node);\n    }\n\n    segmentTreeNode *root;\n    long long query_sum(segmentTreeNode *cur_node, int cur_l, int cur_r, int NEED_L, int NEED_R)\n    {\n        if (cur_l > NEED_R || cur_r < NEED_L)\n            return 0;\n        if (NEED_L <= cur_l && cur_r <= NEED_R)\n            return cur_node->sum;\n        // pushdown(cur_node, 0);\n        long mid = (cur_l + cur_r) >> 1;\n        return query_sum(cur_node->left_son, cur_l, mid, NEED_L, NEED_R) + query_sum(cur_node->right_son, mid + 1, cur_r, NEED_L, NEED_R);\n    }\n\npublic:\n    segmentTree(int left, int right)\n    {\n\n        root = new segmentTreeNode(left, right);\n        all_left = left;\n        all_right = right;\n        // build(root, all_left, all_right, _initValue);\n    }\n\n    void modify(int l, int r, long long add)\n    {\n        modify(root, all_left, all_right, l, r, add);\n    }\n\n    long long query_sum(int l, int r)\n    {\n        return query_sum(root, all_left, all_right, l, r);\n    }\n};\n\nclass Solution\n{\npublic:\n    vector<long long> handleQuery(vector<int> &nums1, vector<int> &nums2, vector<vector<int>> &queries)\n    {\n\n        segmentTree *st = new segmentTree(0, nums1.size() + 1);\n        vector<int> flag_1(nums1.size() + 10);\n        long long cur_sum = 0;\n        for (int j : nums2)\n        {\n            cur_sum += j;\n        }\n\n        for (int i = 0; i < nums1.size(); i++)\n        {\n            if (nums1[i] == 1)\n            {\n                st->modify(i, i, 1);\n            }\n        }\n\n        vector<long long> result;\n        for (int i = 0; i < queries.size(); i++)\n        {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            int c = queries[i][2];\n\n            if (a == 1)\n            {\n                st->modify(b, c, 1);\n            }\n            else if (a == 2)\n            {\n                long long add = st->query_sum(0, nums1.size() + 1);\n                cur_sum += (add * b);\n            }\n            else if (a == 3)\n            {\n                result.push_back(cur_sum);\n            }\n        }\n        return result;\n    }\n};"}]}