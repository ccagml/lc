{"data":[{"name":"2023-02-22 18:00:02","id":1677060002379,"body":"写了很久"},{"name":"2023-02-23 14:05:52","id":1677132352848,"body":"class Solution\n{\n\npublic:\n    int set_bit_1(int x, int index)\n    {\n        x |= (1 << index);\n        return x;\n    }\n    int set_bit_0(int x, int index)\n    {\n        x &= ~(1 << index);\n        return x;\n    }\n\n    bool is_bit_1(int x, int index)\n    {\n        return ((1 << index) & (x));\n    }\n    int squareFreeSubsets(vector<int> &nums)\n    {\n        vector<int> PRIMES = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n\n        vector<int> i_ms(32);\n        // 计算某个数 是不是 有包含这个质数\n        for (int i = 2; i <= 30; i++)\n        {\n            for (int j = 0; j < PRIMES.size(); j++)\n            {\n                int cur_p = PRIMES[j];\n                if (i % cur_p == 0)\n                {\n                    if ((i % (cur_p * cur_p)) == 0)\n                    {\n                        i_ms[i] = -1;\n                        break;\n                    }\n                    i_ms[i] = set_bit_1(i_ms[i], j);\n                }\n            }\n        }\n\n        vector<int> vi(2000);\n        // 空集合\n        vi[0] = 1;\n        int e9 = 1e9 + 7;\n        for (int num : nums)\n        {\n            int num_ms = i_ms[num];\n            if (num_ms >= 0)\n            {\n                for (int check = 1024; check >= num_ms; check--)\n                {\n                    if ((check | num_ms) == check)\n                    {\n\n                        vi[check] = (vi[check] + vi[check ^ num_ms]) % e9;\n                        // std::cout << \"(\" << check << \",\" << vi[check] << \")\";\n                    }\n                }\n            }\n        }\n\n        int result = 0;\n        vi[0]--;\n        for (int i = 0; i < vi.size(); i++)\n        {\n            result += vi[i];\n            result %= e9;\n        }\n\n        return result;\n    }\n};"},{"name":"2023-02-23 14:49:41","id":1677134981088,"body":"Accepted\n44/44 cases passed (44 ms)\nYour runtime beats 44.76 % of cpp submissions\nYour memory usage beats 46.05 % of cpp submissions (9 MB)\nclass Solution\n{\n\npublic:\n    int set_bit_1(int x, int index)\n    {\n        x |= (1 << index);\n        return x;\n    }\n    int set_bit_0(int x, int index)\n    {\n        x &= ~(1 << index);\n        return x;\n    }\n\n    bool is_bit_1(int x, int index)\n    {\n        return ((1 << index) & (x));\n    }\n    int squareFreeSubsets(vector<int> &nums)\n    {\n        // 计算一个数有没有因子\n        vector<int> vi(31);\n        // 给i分解质因数\n\n        vector<int> PRIMES = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n        unordered_map<int, int> num_to_p_index;\n        for (int i = 0; i < PRIMES.size(); i++)\n        {\n            num_to_p_index[PRIMES[i]] = i;\n        }\n        for (int i = 2; i <= 30; i++)\n        {\n\n            unordered_map<int, int> temp = get_primes_list(i);\n\n            for (pair<int, int> pp : temp)\n            {\n                if (pp.second > 1)\n                {\n                    vi[i] = -1;\n                    break;\n                }\n                vi[i] = set_bit_1(vi[i], num_to_p_index[pp.first]);\n            }\n        }\n\n        vector<int> result(2000);\n        result[0] = 1;\n\n        int e9 = 1e9 + 7;\n\n        // result[msk] = 1 数量是msk的数量\n        for (int x : nums)\n        {\n            // x拥有的质因子\n            int x_msk = vi[x];\n\n            if (x_msk >= 0)\n            {\n                // y 质因子的结果数\n                for (int all_msk = 1024; all_msk >= x_msk; all_msk--)\n                {\n                    if ((all_msk | x_msk) == all_msk)\n                    {\n                        result[all_msk] = (result[all_msk] + result[all_msk ^ x_msk]);\n                        result[all_msk] %= e9;\n                    }\n                }\n            }\n        }\n        result[0]--;\n        int int_result = 0;\n        for (int i = 0; i < result.size(); i++)\n        {\n            int_result += result[i];\n            int_result %= e9;\n        }\n        return int_result;\n    }\n\n    unordered_map<int, int> get_primes_list(int n)\n    {\n        unordered_map<int, int> result;\n        int num = n;\n        while (num > 1)\n        {\n            for (int i = 2; i <= n; i++)\n            {\n                while (num > 1 && num % i == 0)\n                {\n                    result[i]++;\n                    num /= i;\n                }\n            }\n        }\n        return result;\n    }\n};\n"}]}