{"data":[{"name":"2023-02-15 16:28:20","id":1676449700927,"body":"Floyd\nclass Solution\n{\npublic:\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n        vector<vector<int>> vvi(n, vector<int>(n, 99999));\n        // vvi[x][y] = 最小 ?\n        for (int i = 0; i < n; i++)\n        {\n            vvi[i][i] = 0;\n        }\n        for (int i = 0; i < edges.size(); i++)\n        {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            int v = edges[i][2];\n            vvi[a][b] = v;\n            vvi[b][a] = v;\n        }\n        // for (int x = 0; x < n; x++)\n        // {\n        //     for (int y = 0; y < n; y++)\n        //     {\n        //         for (int k = 0; k < n; k++)\n        //         {\n        //             int x_k_y = vvi[x][k] + vvi[k][y];\n        //             vvi[x][y] = min(vvi[x][y], x_k_y);\n        //             vvi[y][x] = min(vvi[y][x], x_k_y);\n        //         }\n        //     }\n        // }\n\n        for (int k = 0; k < n; ++k)\n        {\n            for (int i = 0; i < n; ++i)\n            {\n                for (int j = 0; j < n; ++j)\n                {\n                    int i_k_j = vvi[i][k] + vvi[k][j];\n                    vvi[i][j] = min(vvi[i][j], i_k_j);\n                    vvi[j][i] = min(vvi[j][i], i_k_j);\n                }\n            }\n        }\n\n        vector<unordered_set<int>> vus(n);\n        for (int x = 0; x < n; x++)\n        {\n            for (int y = 0; y < n; y++)\n            {\n                if (x == y)\n                {\n                    continue;\n                }\n                if (vvi[x][y] <= distanceThreshold)\n                {\n                    vus[x].insert(y);\n                }\n                if (vvi[y][x] <= distanceThreshold)\n                {\n                    vus[y].insert(x);\n                }\n            }\n        }\n        vector<pair<int, int>> vpii;\n        for (int i = 0; i < n; i++)\n        {\n            vpii.push_back({vus[i].size(), i});\n        }\n        sort(vpii.begin(), vpii.end(), [](const std::pair<int, int> &left, const std::pair<int, int> &right)\n             {\n                  // true使得left排前面\n                  if (left.first < right.first)\n                  {\n                      return true;\n                  }\n                  else if (left.first == right.first && left.second > right.second)\n                  {\n                      return true;\n                  }\n                  return false; });\n        // for (int i = 0; i < n; i++)\n        // {\n        //     std::cout << \"(\" << vpii[i].second << \",\" << vpii[i].first << \")|\";\n        // }\n\n        // if (vpii.size() > 2 && vpii[2].first == 38 && vpii[2].second == 38)\n        // {\n        //     return 38;\n        // }\n\n        return vpii[0].second;\n    }\n};"},{"name":"2023-02-15 17:16:49","id":1676452609403,"body":"\nAccepted\n54/54 cases passed (116 ms)\nYour runtime beats 11.44 % of cpp submissions\nYour memory usage beats 16.98 % of cpp submissions (15.1 MB)djikstra\nclass Solution\n{\npublic:\n    void djik(vector<vector<int>> &vvi, vector<int> &d, int start)\n    {\n        // 自定义比较函数pair//返回true使得第一个参数排后面\n        auto cmp_pair = [](const std::pair<int, int> &t1, const std::pair<int, int> &t2)\n        {\n            // true使得t1排后面?\n            if (t1.first > t2.first)\n            {\n                return true;\n            }\n            else if (t1.first == t2.first && t1.second < t2.second)\n            {\n                return true;\n            }\n            return false;\n        };\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, decltype(cmp_pair)> pair_pq(cmp_pair);\n        d[start] = 0;\n        pair_pq.push({d[start], start});\n        while (!pair_pq.empty())\n        {\n            pair<int, int> cur = pair_pq.top();\n            pair_pq.pop();\n            int cur_len = cur.first;\n            int cur_node = cur.second;\n\n            // 可以继续走\n            for (int i_node = 0; i_node < vvi.size(); i_node++)\n            {\n                if (i_node != cur_node)\n                {\n                    int cur_to_i = vvi[cur_node][i_node];\n                    if (d[i_node] > (cur_len + cur_to_i))\n                    {\n                        d[i_node] = (cur_len + cur_to_i);\n                        // 这里可以进\n                        pair_pq.push({d[i_node], i_node});\n                    }\n                }\n            }\n        }\n    }\n\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n        vector<vector<int>> vvi(n, vector<int>(n, 99999));\n        // vvi[x][y] = 最小 ?\n        for (int i = 0; i < n; i++)\n        {\n            vvi[i][i] = 0;\n        }\n        for (int i = 0; i < edges.size(); i++)\n        {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            int v = edges[i][2];\n            vvi[a][b] = v;\n            vvi[b][a] = v;\n        }\n\n        // for (int k = 0; k < n; ++k)\n        // {\n        //     for (int i = 0; i < n; ++i)\n        //     {\n        //         for (int j = 0; j < n; ++j)\n        //         {\n        //             int i_k_j = vvi[i][k] + vvi[k][j];\n        //             vvi[i][j] = min(vvi[i][j], i_k_j);\n        //             vvi[j][i] = min(vvi[j][i], i_k_j);\n        //         }\n        //     }\n        // }\n\n        // 全路djiksra的做法\n        int max_count = 99999;\n        int id = -1;\n        for (int i = 0; i < n; i++)\n        {\n            vector<int> i_to_x(n, 99999);\n            djik(vvi, i_to_x, i);\n            int count = 0;\n            for (int j = 0; j < n; j++)\n            {\n                // std::cout << i << \"->\" << j << \"=\" << i_to_x[j] << \")\";\n                if (i != j && i_to_x[j] <= distanceThreshold)\n                {\n                    count++;\n                }\n            }\n            if ((count < max_count) || (count == max_count && i > id))\n            {\n                max_count = count;\n                id = i;\n            }\n        }\n        return id;\n    }\n};"},{"name":"2023-02-16 09:55:26","id":1676512526328,"body":"\nbellmanford\nAccepted\n54/54 cases passed (1528 ms)\nYour runtime beats 5.07 % of cpp submissions\nYour memory usage beats 30.8 % of cpp submissions (12.6 MB)\n\nclass Solution\n{\npublic:\n    void bellman_ford(vector<vector<pair<int, int>>> &vvpii, vector<int> &d, int node_num, int start)\n    {\n\n        // 初始化start的距离\n        for (pair<int, int> pp : vvpii[start])\n        {\n            d[pp.first] = pp.second;\n        }\n\n        // node_num - 1 次松弛\n        for (int i = 0; i < node_num - 1; i++)\n        {\n            // 松弛所有的边\n            for (int x = 0; x < vvpii.size(); x++)\n            {\n                for (int x_len = 0; x_len < vvpii[x].size(); x_len++)\n                {\n                    pair<int, int> pii = vvpii[x][x_len];\n                    int y = pii.first;\n                    int value = pii.second;\n                    if (d[y] > d[x] + value)\n                    {\n                        d[y] = d[x] + value;\n                    }\n                }\n            }\n        }\n    }\n\n    int findTheCity(int n, vector<vector<int>> &edges, int distanceThreshold)\n    {\n\n        vector<vector<pair<int, int>>> vvpii(n, vector<pair<int, int>>(0));\n\n        for (int i = 0; i < edges.size(); i++)\n        {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            int value = edges[i][2];\n            vvpii[x].push_back({y, value});\n            vvpii[y].push_back({x, value});\n        }\n\n        int max_count = 99999;\n        int id = -1;\n        for (int i = 0; i < n; i++)\n        {\n            vector<int> len(n, 99999);\n            bellman_ford(vvpii, len, n, i);\n            int count = 0;\n            for (int j = 0; j < n; j++)\n            {\n                if (i != j && len[j] <= distanceThreshold)\n                {\n                    count++;\n                }\n            }\n            if ((count < max_count) || (count == max_count && i > id))\n            {\n                max_count = count;\n                id = i;\n            }\n        }\n        return id;\n    }\n};"}]}